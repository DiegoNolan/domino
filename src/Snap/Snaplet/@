{-# LANGUAGE FlexibleInstances,
             NoImplicitPrelude,
             OverloadedStrings #-}
module Snap.Snaplet.AWS
  ( putFile
  , getFile
  , sendMail
  ) where

import ClassyPrelude
import Control.Lens
import Control.Monad.Representable.State (get)
import Data.Conduit
import Data.Conduit.Binary
import Network.AWS hiding (runAWS)
import qualified Network.AWS as AWS
import Network.AWS.Data.Body
import qualified Network.AWS.S3 as S3
import qualified Network.AWS.SES as SES
import Snap

class MonadIO m => HasAWS m where
  runAWS :: MonadAWS n => n a -> m a

instance HasAWS (Handler b Env) where
  runAWS toRun = do
    env <- get
    runResourceT $ runAWS env $ do a <- toRun
                                   liftAWS


initAWS :: SnapletInit a Env
initAWS = makeSnaplet "aws" "Initialize aws" Nothing $ do
    liftIO $ newEnv Oregon Discover

sendMail :: MonadAWS m
         => Text -- ^ From
         -> [Text] -- ^ To
         -> Text -- ^ subject
         -> Text -- ^ body
         -> m ()
sendMail from to subject b = do
  let dest = SES.destination & SES.dToAddresses .~ to
      bdy = SES.body & SES.bHTML .~ Just (SES.content b)
      msg = SES.message (SES.content subject) bdy
      email = SES.sendEmail from dest msg
  void $ send email

putFile :: (MonadAWS m, ToBody a) => S3.BucketName -> S3.ObjectKey -> Text -> a -> m ()
putFile bucketName key contentType file = do
  let poRe = S3.putObject bucketName key (toBody file)
  void $ send (poRe & S3.poContentType .~ Just contentType)

getFile :: (MonadAWS m) => S3.BucketName -> S3.ObjectKey -> m LByteString
getFile bucketName key = do
  let goRe = S3.getObject bucketName key
  resp <- send goRe
  liftIO $ runResourceT $ do
    (source, finalizer) <- unwrapResumable $ _streamBody (resp ^. S3.gorsBody)
    lbs <- source $$ sinkLbs
    finalizer
    return lbs
